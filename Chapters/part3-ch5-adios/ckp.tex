Most applications face the I/O bottleneck first when scaling up is the dumping of all data necessary to restart the code in case of failures or when a simulation consists of multiple consecutive job executions on machines with time-limited jobs.  Writing checkpoint data represents two classes of I/O challenges: write 1) large or 2) small amount of data, stored in many variables, from every process of the application. In both cases, buffering helps to decrease the amount of individual write operations, thus avoiding I/O latency and utilizing the available I/O bandwidth. In both cases, aggregation is required to decrease the number of entities hitting on the file system at the same time. ADIOS consistently improved all large scale applications' checkpoint writing (and reading) performance by 10-100x and thus allowed for writing checkpoint data of the size of multiple terabytes at a time with acceptable I/O overhead. 

An application, however, does not need to run on tens of thousands of cores to experience I/O bottlenecks. An example application is industrial engineering where Computational Fluid Dynamics (CFD) simulations on billions of cells are necessary today to get new insights in turbulent behaviors. Fine/Turbo is a CFD code of Numeca International. The irregular topology of a specific simulation is partitioned into small regular 3D blocks. Its load balancing algorithm divides up the blocks and the variables on each block among the processes in a way that different variables in a block end up having different sets of processes assigned to them. The original sequential  I/O naturally could not scale up for thousands of cores. Collecting all data on a single core led to too much communication.  Attempts to write in parallel, while retaining each variable of each block organized on the disk as a contiguous block of data, led again to too much communication between processes because the merge of each variable on each block required a gathering operation from a different set of processes. 

ADIOS provided the optimal solution to the writing problem. Each process dealt with its own I/O, thus completely avoided cross-communication among the processes. The data on each process was buffered locally and then, because of the ADIOS-BP file format, it was written into a separate segment of the output file, that is, with one write request with a single seek in the output. The original sequential I/O took 2000 seconds to complete writing (a smallish) 18GB output of a 500 million cells simulation running on 1280 cores. ADIOS, with the single-shared-file approach completed the same I/O in 60 seconds. However, scaling the application up to 8k processes showed the limitations of the single file approach, and therefore aggregation with multiple files was finally used. With aggregation, the above example was completed in 12 seconds, and scalability of the code was maintained for larger simulations on 3.7 billion cells.



